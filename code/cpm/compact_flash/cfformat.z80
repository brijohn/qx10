; Formats Compact Flash card
; For use with version B2.20 only
;
; (c) Copyright 2020-2023 Brian Johnson <brijohn@gmail.com>
ORG  $100

EXTERN CFINIT
EXTERN CFSETCHS
EXTERN CFREAD
EXTERN CFWRITE
EXTERN PRINTSTRING, PRINTWORDSTRING, PRINTHEXWORD, PRINTHEXBYTE

DIRSECTORS    equ  64   ; Native sectors
SPT           equ  64   ; CPM sectors

JP MAIN

PART1MSG:    DEFB "Formatting Partition 1", $0D, $0A, 0
PART2MSG:    DEFB "Formatting Partition 2", $0D, $0A, 0
LBAMSG:      DEFB "       LBA: ", 0
STATUSMSG:   DEFB "    Status: ", 0
NOPARTMSG:   DEFB "No partition found.", 0
LFCR:        DEFB $0A
CR:          DEFB $0D, 0

MAIN:
	CALL DRIVEINIT
	LD  HL, PART1MSG
	CALL PRINTSTRING
	LD  HL, 2              ; start at track 2 of partition
	LD  BC, (PART1OFF)     ; Start at CPM partition 1 offset
	XOR A                  ; Start at CPM sector 0
	CALL FORMAT            ; Format first partition
	LD  HL, PART2MSG
	CALL PRINTSTRING
	LD  HL, 2              ; start at track 2 of partition
	LD  BC, (PART2OFF)     ; Start at CPM partition 2 offset
	XOR A                  ; Start at CPM sector 0
	CALL FORMAT            ; Format second partition
	JP $0000               ; Warm reboot (reload ccp)

; Prints current Sector Address values during formatting
PRINTADDR:
	PUSH AF
	LD  HL, CR
	CALL PRINTSTRING
	LD  HL, LBAMSG
	CALL PRINTSTRING
	LD  A, (HEAD)
	CALL PRINTHEXBYTE
	LD  HL, (CYLINDER)
	CALL PRINTHEXWORD
	LD  A, (SECTOR)
	CALL PRINTHEXBYTE
	LD  HL, STATUSMSG
	CALL PRINTSTRING
	POP AF
	CALL PRINTHEXBYTE
	RET

DRIVEINIT:
	CALL CFINIT
	XOR A
	LD  E, A
	LD  B, A
	LD  C, A
	CALL CFSETCHS                 ; LBA = 0
	LD  D, 1                      ; Read 1 Sector
	LD  HL, MBR                   ; MBR buffer
	CALL CFREAD                   ; Read MBR
	LD  HL,(MBR+$1FE)
	LD  DE,$AA55
	OR  A                         ; Clear carry bit
	SBC HL,DE                     ; Check if signautre is equal to aa55
	JP  NZ,EXIT_INIT              ; If not exit
	LD  HL,MBR+$1C2               ; HL = Address of first partion entry+4 (Type)
	LD  DE,$10                    ; DE = Partion entry size (16)
	LD  B,4                       ; B = Max size of partition table (4)
NEXTPART:
	LD  A,(HL)                    ; A = partition type
	CP  $F0                       ;
	JR  Z,FOUNDPART               ; If type == 0xF0 we found avalid partition
	ADD HL,DE                     ; Else check next partition's type
	DJNZ NEXTPART                 ; Next partition
	JR  EXIT_INIT                 ; If no valid partition found exit with failure
FOUNDPART:
	PUSH HL                       ; Store partition entry pointer on stack
	DEC HL                        ; HL = address of partition start cylinder (7-0)
	LD  E,(HL)                    ; E = Low 8 bits of start cylinder
	DEC HL                        ; HL = address of starting sector/high bits of cylinder
	LD  A,(HL)                    ; A = (7-6) high bits of cylinder, (5-0) sector
	AND $C0                       ; Keep only cylinder bits
	RLCA                          ;
	RLCA                          ; Rotate bits 7-6 -> 1-0
	LD  D,A                       ; DE = starting cylinder
	DEC HL                        ; HL = address of starting head
	LD  C,(HL)                    ;
	LD  B,$00                     ; BC = head
	EX  DE,HL                     ; HL = cylinder
	ADD HL,HL                     ;
	ADD HL,HL                     ;
	ADD HL,BC                     ; HL = (cylinder * 4) + head
	LD (PART1OFF),HL              ; Store offset to start of partition
	POP HL
	INC HL                        ; HL = address of end of partition head
	LD  C,(HL)                    ; C = head
	INC HL                        ; HL = address of end of partition top bits of cylinder (7-6)
	LD  A,(HL)                    ; A = (7-6) high bits of cylinder
	AND $C0                       ; Keep only the top cylinder bits
	RLCA                          ;
	RLCA                          ; Rotate bits 7-6 -> 1-0
	INC HL                        ; HL = address of end of partition cylinder (5-0)
	LD  L,(HL)                    ;
	LD  H,A                       ; HL = end of partition cylinder
	ADD HL,HL
	ADD HL,HL
	ADD HL,BC                     ; HL = (cylinder * 4) + head
	LD  DE,(PART1OFF)             ; DE = offset to start of maiin partition
	OR  A                         ; Clear carry bit
	SBC HL,DE                     ; Calculate total length of first partition
	INC HL                        ; HL += 1
	SRL H                         ;
	RR  L                         ; Divide length by 2
	ADD HL,DE                     ;
	LD  (PART2OFF),HL             ; Set start of second partition (length of first partition)
	RET
EXIT_INIT:
	LD  HL,NOPARTMSG
	CALL PRINTSTRING
	JP  $0000

; Format partition
; HL = starting track
; BC = Partition offset
; A  = starting sector
FORMAT:
	ADD HL,BC
	LD  (CPMTRACK), HL     ; Store track number
	LD  (CPMSECTOR), A     ; Store Sector number
	LD  D, DIRSECTORS      ; D = number of sectors for directory
NEXTBLOCK:
	PUSH DE                ; Preserve DE
	CALL SETADDR           ; Convert CPM track/sector to Sector Address values and setup CF
	LD  D, 1               ; D  = number of sectors to write 
	LD  HL, BUFFER         ; HL = sector buffer 
	CALL CFWRITE           ; Write sector
	CALL PRINTADDR         ; Update screen with current Sector Address values
	POP DE                 ; Restore DE
	LD  HL, (CPMTRACK)     ; BC = current track
	LD  A, (CPMSECTOR)     ; A  = current sector
	ADD A, $04             ; Increment sector count by 4 (4 cpm sectors per one CF sector)
	CP  SPT                ; Compare sector count to number of cpm sectors per track
	JR  NZ, SKIPTRACKINC
	INC  HL                ; If equal increment track
	LD  (CPMTRACK), HL     ; and store new track value for next write
	XOR A                  ; then zero sector count
SKIPTRACKINC:
	LD  (CPMSECTOR), A     ; Store cpm sector for next write
	DEC D                  ; Decrement count of remaining sectors to write
	JR  NZ, NEXTBLOCK      ; If not zero write next sector
	LD  HL, LFCR
	CALL PRINTSTRING       ; Print newline
	RET

; Convert CPM track/sector to Sector Address values
; HL = Track
; A  = Sector
SETADDR:
	SRL A                  ; Divide CPM Sector by 4
	SRL A
	ADD  HL, HL            ; Shift CPMTRACK left by 4
	ADD  HL, HL            ; There are 16 sectors per track
	ADD  HL, HL            ; so this will multiply the current
	ADD  HL, HL            ; track by 16.
	AND  $0F               ; Ensure sector is between 0-15
	ADD  A, L              ; Add sector to low byte of track
	LD   (SECTOR), A       ; Store LBA7-0 for later
	LD   E, A              ; and move it to E
	LD   A, H
	LD   (CYLINDER), A     ; Store LBA15-8 for later
	XOR  A
	LD   (CYLINDER+1), A   ; LBA24-16 is always 0
	LD   (HEAD), A         ; Same with LBA28-25
	LD   BC, (CYLINDER)    ; BC should contain LBA24-8
	CALL CFSETCHS          ; Write LBA info to CF in preperation for read/write
	RET

CPMTRACK:  DEFW 0
CPMSECTOR: DEFB 0
CYLINDER:  DEFW 0
HEAD:      DEFB 0
SECTOR:    DEFB 0
PART1OFF:  DEFW 0
PART2OFF:  DEFW 0

MBR   :    DS 512
BUFFER:    DS 512, $E5
